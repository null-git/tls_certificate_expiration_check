#!/usr/bin/perl
#
# check_tls_certificate_expiration - Check for nagios/icinga/icinga2 to check TLS Certificates
# Copyright (C) 2015  Josef 'veloc1ty' Stautner (hello@veloc1ty.de)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use Getopt::Long;
use Date::Calc qw(Delta_Days Decode_Month Today);

our $OPENSSL_PATH = '/usr/bin/openssl';
our $WARNING_DAYS = 30;
our $CRITICAL_DAYS = 10;
our $MODE = 'network';

# Config option for network mode
our $ADDRESS = '';
our $PORT = '';
our $SNI_HOSTNAME = '';

# Config option for file mode
our $FILEPATH = '';

main();

sub main {
	check_for_openssl();
	parse_options();
	check_critical_less_than_warning();

	my $expireDate = '';

	if ( $mode eq 'network' ) {
		$expireDate = fetch_certificate_from_network($ADDRESS, $PORT, $SNI_HOSTNAME);
	}
	elsif ( $mode eq 'file' ) {
		$expireDate = fetch_certificate_from_file($FILEPATH);
	}
	else {
		exit_unknown('Given mode is unknown');
	}

	decide_exit_code(calculate_days_left($expireDate));
}

sub exit_unknown {
	my $errorMessage = shift;
	print("$errorMessage\n");
	exit 3;
}

sub decide_exit_code {
	my $daysLeft = shift;

	if ( $daysLeft > $WARNING_DAYS ) {
		print("OK - $daysLeft days left \n");
		exit 0;
	}
	elsif ( $daysLeft > $CRITICAL_DAYS && $daysLeft <= $WARNING_DAYS ) {
		print("WARNING - Certificate is going to expire in $daysLeft days\n");
		exit 1;
	}
	elsif ( $daysLeft <= $CRITICAL_DAYS ) {
		print("CRITICAL - Certificate is going to expire in $daysLeft days\n");
		exit 2;
	}
}

sub fetch_certificate_from_network {
	my ( $address, $port, $sniHostname ) = @_;

	my $result = `echo | $OPENSSL_PATH s_client -connect $address:$port -servername $sniHostname 2>/dev/null | $OPENSSL_PATH x509 -noout -dates | grep notAfter`;

	return extract_expiry_dayte_from_openssl_putput($result);
}

sub fetch_certificate_from_file {
	my ( $filepath ) = @_;

	exit_unknown("Certificate under $filepath was not found. Plese check the path") if ( ! -e $filepath );

	my $result = `$OPENSSL_PATH x509 -noout -dates -in $filepath | grep notAfter`;

	return extract_expiry_dayte_from_openssl_putput($result);
}

sub extract_expiry_dayte_from_openssl_putput {
	my $expireDate = shift;

	$expireDate =~ s/not.*=//ig;
	chomp($expireDate);

	exit_unknown("Didn't get an expire date from OpenSSL" ) if ( length($expireDate) == 0 );

	return $expireDate;
}

sub calculate_days_left {
	my $expireDate = shift;

	my ($month, $day, $time, $year, $tz) = split(/\s+/, $expireDate);

	my ( $nowYear, $nowMonth, $nowDay) = Today();

	return Delta_Days($nowYear, $nowMonth, $nowDay,
		$year, Decode_Month($month), $day);
}

sub check_for_openssl {
	exit_unknown("OpenSSL not found under $OPENSSL_PATH") if ( ! -e $OPENSSL_PATH );
}

sub parse_options {
	GetOptions (
		"warn=i" => \$WARNING_DAYS,
		"crit=i" => \$CRITICAL_DAYS,
		"help" => \&print_help
		);
}

sub check_critical_less_than_warning {
	exit_unknown("critical value ($CRITICAL_DAYS) is greater than warning value ($WARNING_DAYS)") if ( $CRITICAL_DAYS > $WARNING_DAYS );
}

sub print_help {
	print << "END_MESSAGE";
check_tls_certificate_expiration - Monitor expiration of a TLS certificate
Copyright (c) 2015 Josef 'veloc1ty' Stautner (hello\@veloc1ty.de)

Usage:
	--mode	 = Which mode to run. Possible values currently are 'file' and 'network'
			   network mode: Connect to a network service and analyze the presented certificate
			   file mode: Read a certificate from the file system
	--warn       = Warning limit in days before expiry date. Default: $WARNING_DAYS
	--crit       = Critical limit in days before expiry date. Default: $CRITICAL_DAYS
	--help       = Print this message

Extra arguments:
	For 'network' mode:
		--address		= The address of the server (IP or Hostname)
		--port		= The port (Default is $PORT)
		--sniHostname 	= The hostname to send for SNI process

	For 'file' mode:
		--file		= (Full-)Path to the certificate

Special thanks:
	1) shellhacks.com - For the tips to extract the expire date of the server response (see get_expiry_date)
	http://www.shellhacks.com/en/HowTo-Check-SSL-Certificate-Expiration-Date-from-the-Linux-Shell

	2) Jan from biocrafting.net for notifying me about the SNI issue!

END_MESSAGE

	exit 0;
}
